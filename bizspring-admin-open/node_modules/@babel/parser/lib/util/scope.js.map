{"version":3,"names":["_scopeflags","require","_parseError","Scope","constructor","flags","var","Set","lexical","functions","exports","ScopeHandler","parser","inModule","scopeStack","undefinedExports","Map","inTopLevel","currentScope","ScopeFlag","PROGRAM","inFunction","currentVarScopeFlags","FUNCTION","allowSuper","currentThisScopeFlags","SUPER","allowDirectSuper","DIRECT_SUPER","inClass","CLASS","inClassAndNotInNonArrowFunction","inStaticBlock","i","length","STATIC_BLOCK","VAR","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","createScope","enter","push","exit","scope","pop","declareName","name","bindingType","loc","BindingFlag","SCOPE_LEXICAL","SCOPE_FUNCTION","checkRedeclarationInScope","add","maybeExportDefined","SCOPE_VAR","delete","isRedeclaredInScope","raise","Errors","VarRedeclaration","at","identifierName","KIND_VALUE","has","SIMPLE_CATCH","values","next","value","checkLocalExport","id","topLevelScope","set","start","ARROW","default"],"sources":["../../src/util/scope.ts"],"sourcesContent":["import { ScopeFlag, BindingFlag, type BindingTypes } from \"./scopeflags\";\nimport type { Position } from \"./location\";\nimport type * as N from \"../types\";\nimport { Errors } from \"../parse-error\";\nimport type Tokenizer from \"../tokenizer\";\n\n// Start an AST node, attaching a start offset.\nexport class Scope {\n  declare flags: ScopeFlag;\n  // A set of var-declared names in the current lexical scope\n  var: Set<string> = new Set();\n  // A set of lexically-declared names in the current lexical scope\n  lexical: Set<string> = new Set();\n  // A set of lexically-declared FunctionDeclaration names in the current lexical scope\n  functions: Set<string> = new Set();\n\n  constructor(flags: ScopeFlag) {\n    this.flags = flags;\n  }\n}\n\n// The functions in this module keep track of declared variables in the\n// current scope in order to detect duplicate variable names.\nexport default class ScopeHandler<IScope extends Scope = Scope> {\n  parser: Tokenizer;\n  scopeStack: Array<IScope> = [];\n  inModule: boolean;\n  undefinedExports: Map<string, Position> = new Map();\n\n  constructor(parser: Tokenizer, inModule: boolean) {\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n\n  get inTopLevel() {\n    return (this.currentScope().flags & ScopeFlag.PROGRAM) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & ScopeFlag.CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & ScopeFlag.CLASS) > 0 && (flags & ScopeFlag.FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (ScopeFlag.VAR | ScopeFlag.CLASS)) {\n        // function body, module body, class property initializers\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags: ScopeFlag): Scope {\n    return new Scope(flags);\n  }\n\n  enter(flags: ScopeFlag) {\n    /*:: +createScope: (flags:ScopeFlag) => IScope; */\n    // @ts-expect-error This method will be overwritten by subclasses\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit(): ScopeFlag {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\n    return !!(\n      scope.flags & (ScopeFlag.FUNCTION | ScopeFlag.STATIC_BLOCK) ||\n      (!this.parser.inModule && scope.flags & ScopeFlag.PROGRAM)\n    );\n  }\n\n  declareName(name: string, bindingType: BindingTypes, loc: Position) {\n    let scope = this.currentScope();\n    if (\n      bindingType & BindingFlag.SCOPE_LEXICAL ||\n      bindingType & BindingFlag.SCOPE_FUNCTION\n    ) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n\n      if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BindingFlag.SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n\n        if (scope.flags & ScopeFlag.VAR) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope: IScope, name: string) {\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n    loc: Position,\n  ) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n  }\n\n  isRedeclaredInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (!(bindingType & BindingFlag.KIND_VALUE)) return false;\n\n    if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n      return (\n        scope.lexical.has(name) ||\n        scope.functions.has(name) ||\n        scope.var.has(name)\n      );\n    }\n\n    if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n      return (\n        scope.lexical.has(name) ||\n        (!this.treatFunctionsAsVarInScope(scope) && scope.var.has(name))\n      );\n    }\n\n    return (\n      (scope.lexical.has(name) &&\n        // Annex B.3.4\n        // https://tc39.es/ecma262/#sec-variablestatements-in-catch-blocks\n        !(\n          scope.flags & ScopeFlag.SIMPLE_CATCH &&\n          scope.lexical.values().next().value === name\n        )) ||\n      (!this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name))\n    );\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (\n      !topLevelScope.lexical.has(name) &&\n      !topLevelScope.var.has(name) &&\n      // In strict mode, scope.functions will always be empty.\n      // Modules are strict by default, but the `scriptMode` option\n      // can overwrite this behavior.\n      !topLevelScope.functions.has(name)\n    ) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n\n  currentScope(): IScope {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.VAR) {\n        return flags;\n      }\n    }\n  }\n\n  // Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  currentThisScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (\n        flags & (ScopeFlag.VAR | ScopeFlag.CLASS) &&\n        !(flags & ScopeFlag.ARROW)\n      ) {\n        return flags;\n      }\n    }\n  }\n}\n"],"mappings":"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"}